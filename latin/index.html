<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lector Latinus - Interactive Latin Reader</title>
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React and ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    
    <!-- Babel for translating JSX in the browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Custom Font -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Crimson+Text:ital,wght@0,400;0,700;1,400&family=Inter:wght@400;700&display=swap');
        body { font-family: 'Crimson Text', serif; }
        .font-sans { font-family: 'Inter', sans-serif; }
    </style>
</head>
<body class="bg-[#f7f5f0] text-stone-800">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- ICONS (Inlined for single-file portability) ---
        const Icons = {
            BookOpen: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></svg>,
            Info: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>,
            Type: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" y1="20" x2="15" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/></svg>,
            X: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M18 6 6 18"/><path d="m6 6 18 18"/></svg>,
            Globe: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 2a14.5 14.5 0 0 0 0 20 14.5 14.5 0 0 0 0-20"/><path d="M2 12h20"/></svg>,
            Wifi: () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M5 12.55a11 11 0 0 1 14.08 0"/><path d="M1.42 9a16 16 0 0 1 21.16 0"/><path d="M8.53 16.11a6 6 0 0 1 6.95 0"/><line x1="12" y1="20" x2="12.01" y2="20"/></svg>
        };

        // --- DATA & LOGIC ENGINE ---

        // 1. The "Gold Standard" Dictionary (Local Cache)
        const LOCAL_DICTIONARY = {
            "in": { lemma: "in", def: "in, on, at", parse: "Prep (Abl/Acc)" },
            "principio": { lemma: "principium", def: "beginning, origin", parse: "Abl Sg Neut" },
            "erat": { lemma: "sum", def: "to be, exist", parse: "Impf Ind Act 3S" },
            "verbum": { lemma: "verbum", def: "word, speech", parse: "Nom Sg Neut" },
            "et": { lemma: "et", def: "and", parse: "Conj" },
            "apud": { lemma: "apud", def: "at, by, near, among", parse: "Prep (Acc)" },
            "deum": { lemma: "deus", def: "God, deity", parse: "Acc Sg Masc" },
            "deus": { lemma: "deus", def: "God, deity", parse: "Nom Sg Masc" },
            "hoc": { lemma: "hic", def: "this", parse: "Nom Sg Neut" },
            "omnia": { lemma: "omnis", def: "all, every", parse: "Nom Pl Neut" },
            "per": { lemma: "per", def: "through, by means of", parse: "Prep (Acc)" },
            "ipsum": { lemma: "ipse", def: "himself, itself", parse: "Acc Sg Masc" },
            "facta": { lemma: "facio", def: "made, done", parse: "Perf Pass Part Nom Pl Neut" },
            "sunt": { lemma: "sum", def: "to be", parse: "Pres Ind Act 3P" },
            "sine": { lemma: "sine", def: "without", parse: "Prep (Abl)" },
            "ipso": { lemma: "ipse", def: "himself, itself", parse: "Abl Sg Masc" },
            "factum": { lemma: "facio", def: "made, done", parse: "Perf Pass Part Nom Sg Neut" },
            "est": { lemma: "sum", def: "is", parse: "Pres Ind Act 3S" },
            "nihil": { lemma: "nihil", def: "nothing", parse: "Nom/Acc Sg Neut" },
            "quod": { lemma: "qui", def: "which, what", parse: "Nom Sg Neut" },
            "vita": { lemma: "vita", def: "life", parse: "Nom Sg Fem" },
            "lux": { lemma: "lux", def: "light", parse: "Nom Sg Fem" },
            "hominum": { lemma: "homo", def: "man, human", parse: "Gen Pl Masc" },
            "lucet": { lemma: "luceo", def: "shine, be light", parse: "Pres Ind Act 3S" },
            "tenebrae": { lemma: "tenebrae", def: "darkness", parse: "Nom Pl Fem" },
            "eam": { lemma: "is", def: "her, it", parse: "Acc Sg Fem" },
            "non": { lemma: "non", def: "not", parse: "Adv" },
            "comprehenderunt": { lemma: "comprehendo", def: "seize, grasp, understand", parse: "Perf Ind Act 3P" }
        };

        // 2. The Heuristic Analyzer (Fallback)
        const analyzeUnknownWord = (word) => {
            const clean = word.toLowerCase().replace(/[.,;?!]/g, '');
            const endings = [
                { suffix: 'bus', parse: 'Dat/Abl Pl', guess: 'Noun/Adj' },
                { suffix: 'ntur', parse: 'Pres Ind Pass 3P', guess: 'Verb' },
                { suffix: 'mur', parse: 'Pres Ind Pass 1P', guess: 'Verb' },
                { suffix: 'mus', parse: 'Pres Ind Act 1P', guess: 'Verb' },
                { suffix: 'tis', parse: 'Pres Ind Act 2P', guess: 'Verb' },
                { suffix: 'nt', parse: 'Pres Ind Act 3P', guess: 'Verb' },
                { suffix: 'ns', parse: 'Pres Part', guess: 'Participle' },
                { suffix: 'am', parse: 'Acc Sg Fem', guess: 'Noun 1st Decl' },
                { suffix: 'um', parse: 'Acc Sg Masc / Nom Neut', guess: 'Noun 2nd Decl' },
                { suffix: 'em', parse: 'Acc Sg M/F', guess: 'Noun 3rd Decl' },
                { suffix: 'as', parse: 'Acc Pl Fem', guess: 'Noun 1st Decl' },
                { suffix: 'os', parse: 'Acc Pl Masc', guess: 'Noun 2nd Decl' },
                { suffix: 'es', parse: 'Nom/Acc Pl M/F', guess: 'Noun 3rd Decl' },
                { suffix: 'ae', parse: 'Gen/Dat Sg or Nom Pl', guess: 'Noun 1st Decl' },
                { suffix: 'i', parse: 'Gen Sg / Nom Pl', guess: 'Noun 2nd Decl' },
                { suffix: 'o', parse: 'Dat/Abl Sg', guess: 'Noun 2nd Decl' },
                { suffix: 'a', parse: 'Nom/Abl Sg Fem or Nom/Acc Pl Neut', guess: 'Noun' },
                { suffix: 'us', parse: 'Nom Sg Masc', guess: 'Noun 2nd Decl' },
                { suffix: 'is', parse: 'Gen Sg / Dat/Abl Pl', guess: 'Noun 3rd Decl' },
                { suffix: 't', parse: 'Pres Ind Act 3S', guess: 'Verb' },
            ];

            for (let rule of endings) {
                if (clean.endsWith(rule.suffix)) {
                    return {
                        lemma: clean.slice(0, -rule.suffix.length) + '-', 
                        def: `(Analysis failed, guessing ${rule.guess})`, 
                        parse: rule.parse + '?'
                    };
                }
            }
            return { lemma: clean, def: "Definition unavailable", parse: "Unknown" };
        };

        // 3. Wiktionary API Integration
        const fetchWiktionaryData = async (word) => {
            try {
                const response = await fetch(`https://en.wiktionary.org/w/api.php?action=query&titles=${word}&prop=revisions&rvprop=content&format=json&origin=*`);
                const data = await response.json();
                const pages = data.query.pages;
                const pageId = Object.keys(pages)[0];
                
                if (pageId === '-1') return null; // Word not found

                const content = pages[pageId].revisions[0]['*'];
                
                // parsing strategy
                if (!content.includes('==Latin==')) return null;

                // FIX: Better splitting to avoid cutting off at ===Subheaders===
                const parts = content.split(/==\s*Latin\s*==/);
                if (parts.length < 2) return null;
                
                let latinSection = parts[1];
                // Check if there is another language section after this one (Level 2 header)
                const nextLangMatch = latinSection.search(/\n==[^=]/);
                if (nextLangMatch !== -1) {
                    latinSection = latinSection.substring(0, nextLangMatch);
                }

                // 1. Look for Definition (lines starting with #)
                let definition = "Definition not parsed";
                // Regex looks for a line starting with #, optionally followed by templates like {{lb|la|...}}
                const defMatch = latinSection.match(/\n#\s*(\{\{[^}]+\}\})*\s*([^\n]+)/);
                
                if (defMatch) {
                    // defMatch[2] captures the text after the # and optional initial templates
                    let rawDef = defMatch[2] || defMatch[1]; 
                    
                    if (rawDef) {
                        definition = rawDef
                            .replace(/\[\[([^\]|]+\|)?([^\]]+)\]\]/g, '$2') // Simplify links [[link|text]] -> text
                            .replace(/\{\{([^\}\|]+)(\|[^\}]+)?\}\}/g, '') // Remove templates
                            .replace(/''/g, '') // Remove italics
                            .replace(/&lt;[^&]+&gt;/g, '') // Remove html tags
                            .trim();
                            
                        // Fallback if regex stripped everything
                        if (!definition && defMatch[0]) {
                             definition = defMatch[0].replace(/\n#\s*/, '').replace(/\{\{[^}]+\}\}/g, '').trim();
                        }
                    }
                }

                // 2. Look for Inflection Template (Parsing)
                // matches {{inflection of|la|lemma||...}}
                let parse = "Form of...";
                let lemma = word;
                
                const inflectionMatch = latinSection.match(/\{\{inflection of\|la\|([^}|]+)\|([^}]+)\}\}/);
                
                if (inflectionMatch) {
                    lemma = inflectionMatch[1];
                    const tags = inflectionMatch[2].split('|').filter(t => t && t.trim() !== '');
                    
                    // Map common Wiktionary tags to our standard
                    const tagMap = {
                        '1': '1P', '2': '2P', '3': '3P', 
                        's': 'Sg', 'p': 'Pl',
                        'pres': 'Pres', 'impf': 'Impf', 'perf': 'Perf', 'fut': 'Fut', 'plup': 'Plup',
                        'ind': 'Ind', 'sub': 'Subj', 'imp': 'Imp',
                        'act': 'Act', 'pass': 'Pass',
                        'nom': 'Nom', 'gen': 'Gen', 'dat': 'Dat', 'acc': 'Acc', 'abl': 'Abl', 'voc': 'Voc',
                        'm': 'Masc', 'f': 'Fem', 'n': 'Neut'
                    };

                    parse = tags.map(t => tagMap[t] || t).join(' ');
                } else {
                    // Fallback checks for main entries
                    if (latinSection.includes('{{la-noun')) parse = "Noun";
                    else if (latinSection.includes('{{la-verb')) parse = "Verb";
                    else if (latinSection.includes('{{la-adj')) parse = "Adjective";
                    else if (latinSection.includes('{{la-prep')) parse = "Preposition";
                    else if (latinSection.includes('{{la-adv')) parse = "Adverb";
                    else if (latinSection.includes('{{la-conj')) parse = "Conjunction";
                }

                return { lemma, def: definition, parse, source: 'Wiktionary' };

            } catch (error) {
                console.error("Wiktionary fetch error:", error);
                return null;
            }
        };

        // --- COMPONENTS ---

        const Tooltip = ({ data, position, onClose, isLoading }) => {
            if (!data && !isLoading) return null;

            // Simple scaling for mobile responsiveness on tooltip
            const style = { 
                left: position.x, 
                top: position.y,
                maxWidth: '90vw'
            };

            return (
                <div 
                    className="absolute z-50 bg-white border border-stone-300 shadow-xl rounded-lg p-4 w-64 text-sm font-serif transform -translate-x-1/2 mt-2"
                    style={style}
                >
                    <div className="flex justify-between items-start border-b border-stone-200 pb-2 mb-2">
                        <div>
                        {isLoading ? (
                            <h3 className="text-xl font-bold text-stone-400 animate-pulse">Loading...</h3>
                        ) : (
                            <React.Fragment>
                                <h3 className="text-xl font-bold text-stone-900 leading-none">{data.word}</h3>
                                <span className="text-xs text-stone-500 italic font-sans">from {data.lemma}</span>
                            </React.Fragment>
                        )}
                        </div>
                        <button onClick={onClose} className="text-stone-400 hover:text-stone-700">
                            <Icons.X />
                        </button>
                    </div>
                    
                    {isLoading ? (
                        <div className="space-y-2 animate-pulse">
                            <div className="h-4 bg-stone-200 rounded w-3/4"></div>
                            <div className="h-4 bg-stone-200 rounded w-1/2"></div>
                        </div>
                    ) : (
                        <React.Fragment>
                            <div className="space-y-2">
                                <div>
                                <span className="block text-xs font-sans font-bold text-stone-500 uppercase tracking-wide">Definition</span>
                                <p className="text-stone-800 line-clamp-4">{data.def}</p>
                                </div>
                                
                                <div>
                                <span className="block text-xs font-sans font-bold text-stone-500 uppercase tracking-wide">Parsing</span>
                                <div className="inline-flex items-center px-2 py-1 rounded bg-stone-100 text-stone-700 font-mono text-xs border border-stone-200">
                                    {data.parse}
                                </div>
                                </div>
                            </div>
                            <div className="mt-3 flex items-center justify-center gap-1 text-[10px] text-stone-400 font-sans">
                                <div className="w-3 h-3 scale-75">{data.source === 'Wiktionary' && <Icons.Globe />}</div>
                                <div className="w-3 h-3 scale-75">{data.source === 'precise' && <Icons.BookOpen />}</div>
                                <div className="w-3 h-3 scale-75">{data.source === 'heuristic' && <Icons.Type />}</div>
                                <span>
                                    {data.source === 'precise' ? 'Verified Local Entry' : 
                                    data.source === 'Wiktionary' ? 'Live Wiktionary Data' : 'Algorithmic Guess'}
                                </span>
                            </div>
                        </React.Fragment>
                    )}
                </div>
            );
        };

        const LatinReader = () => {
            const [inputText, setInputText] = useState("In principio erat Verbum, et Verbum erat apud Deum, et Deus erat Verbum.");
            const [activeWordData, setActiveWordData] = useState(null);
            const [loading, setLoading] = useState(false);
            const [tooltipPos, setTooltipPos] = useState({ x: 0, y: 0 });
            const [wordCache, setWordCache] = useState({});
            const containerRef = useRef(null);

            const handleWordClick = async (e, word) => {
                e.stopPropagation();
                const cleanWord = word.toLowerCase().replace(/[^a-z]/g, '');
                if (!cleanWord) return;

                const rect = e.target.getBoundingClientRect();
                const containerRect = containerRef.current.getBoundingClientRect();
                const pos = {
                    x: rect.left - containerRect.left + (rect.width / 2),
                    y: rect.bottom - containerRect.top
                };
                setTooltipPos(pos);
                setLoading(true);
                setActiveWordData(null); 

                // 1. Check Local Dictionary
                if (LOCAL_DICTIONARY[cleanWord]) {
                    setActiveWordData({ ...LOCAL_DICTIONARY[cleanWord], word: word.replace(/[.,;?!]/g, ''), source: 'precise' });
                    setLoading(false);
                    return;
                }

                // 2. Check Cache
                if (wordCache[cleanWord]) {
                    setActiveWordData({ ...wordCache[cleanWord], word: word.replace(/[.,;?!]/g, '') });
                    setLoading(false);
                    return;
                }

                // 3. Fetch Wiktionary
                const wikiResult = await fetchWiktionaryData(cleanWord);
                
                if (wikiResult) {
                    const result = { ...wikiResult, word: word.replace(/[.,;?!]/g, '') };
                    setWordCache(prev => ({ ...prev, [cleanWord]: result }));
                    setActiveWordData(result);
                } else {
                    // 4. Fallback
                    const heuristic = analyzeUnknownWord(cleanWord);
                    setActiveWordData({ ...heuristic, word: word.replace(/[.,;?!]/g, ''), source: 'heuristic' });
                }
                
                setLoading(false);
            };

            return (
                <div className="min-h-screen p-4 md:p-8" onClick={() => setActiveWordData(null)}>
                    <div className="max-w-3xl mx-auto">
                        
                        <header className="mb-8 border-b-2 border-stone-800 pb-4 flex justify-between items-end">
                            <div>
                                <h1 className="text-4xl font-black tracking-tight text-stone-900">LECTOR LATINUS</h1>
                                <p className="text-stone-600 mt-2 font-sans text-sm">Interactive Morphological Parser & Reader</p>
                            </div>
                            <div className="hidden md:block text-right text-xs font-sans text-stone-500">
                                <div className="flex items-center justify-end gap-1 text-green-600">
                                     <div className="w-3 h-3"><Icons.Wifi /></div> <span className="font-bold">Online Mode</span>
                                </div>
                                <p>Wiktionary API Connected</p>
                            </div>
                        </header>

                        <div className="bg-white border-l-4 border-amber-600 p-4 mb-6 shadow-sm rounded-r-lg">
                            <div className="flex gap-3">
                                <div className="text-amber-600 shrink-0 w-6 h-6"><Icons.Info /></div>
                                <div className="text-sm font-sans text-stone-700">
                                    <p className="font-bold mb-1">How it works:</p>
                                    <p>Type any Latin text. The system first checks a verified local list (John 1), then queries <strong>Wiktionary</strong> live, and finally guesses if needed.</p>
                                </div>
                            </div>
                        </div>

                        <div className="mb-8">
                            <label className="flex items-center gap-2 text-xs font-bold font-sans uppercase tracking-wider text-stone-400 mb-2">
                                <div className="w-3.5 h-3.5"><Icons.Type /></div> Input Source Text
                            </label>
                            <textarea
                                className="w-full h-32 p-4 rounded-lg border border-stone-300 shadow-inner bg-white focus:ring-2 focus:ring-stone-400 focus:border-stone-400 outline-none transition font-serif text-lg resize-y"
                                value={inputText}
                                onChange={(e) => setInputText(e.target.value)}
                                placeholder="Paste Latin text here (e.g., Gallia est omnis divisa in partes tres...)"
                                onClick={(e) => e.stopPropagation()} 
                            />
                        </div>

                        <div className="relative">
                             <label className="flex items-center gap-2 text-xs font-bold font-sans uppercase tracking-wider text-stone-400 mb-2">
                                <div className="w-3.5 h-3.5"><Icons.BookOpen /></div> Interactive Reader
                            </label>
                            
                            <div 
                                ref={containerRef}
                                className="bg-white p-8 rounded-xl shadow-lg border border-stone-200 min-h-[300px] leading-loose text-xl md:text-2xl text-justify"
                                style={{ position: 'relative' }} 
                                onClick={(e) => e.stopPropagation()}
                            >
                                {inputText.split(/(\s+)/).map((segment, index) => {
                                    if (segment.match(/^\s+$/)) return <span key={index}>{segment}</span>;
                                    
                                    return (
                                        <span 
                                            key={index}
                                            className="relative cursor-pointer hover:bg-amber-100 hover:text-amber-900 rounded px-0.5 transition-colors duration-200 group border-b border-transparent hover:border-amber-300 select-none"
                                            onClick={(e) => handleWordClick(e, segment)}
                                        >
                                            {segment}
                                        </span>
                                    );
                                })}

                                <Tooltip 
                                    data={activeWordData} 
                                    position={tooltipPos} 
                                    isLoading={loading}
                                    onClose={() => setActiveWordData(null)}
                                />
                            </div>
                        </div>

                        <div className="mt-12 grid grid-cols-2 md:grid-cols-4 gap-4 text-xs font-sans text-stone-500 border-t border-stone-200 pt-6">
                            <div>
                                <strong className="block text-stone-900 mb-1">Parts of Speech</strong>
                                <ul className="space-y-1">
                                    <li>Nom: Nominative</li>
                                    <li>Gen: Genitive</li>
                                    <li>Dat: Dative</li>
                                    <li>Acc: Accusative</li>
                                </ul>
                            </div>
                            <div>
                                <strong className="block text-stone-900 mb-1">&nbsp;</strong>
                                <ul className="space-y-1">
                                    <li>Abl: Ablative</li>
                                    <li>Voc: Vocative</li>
                                    <li>Sg/Pl: Singular/Plural</li>
                                </ul>
                            </div>
                            <div>
                                <strong className="block text-stone-900 mb-1">Verbs</strong>
                                <ul className="space-y-1">
                                    <li>Pres: Present</li>
                                    <li>Impf: Imperfect</li>
                                    <li>Perf: Perfect</li>
                                    <li>Fut: Future</li>
                                </ul>
                            </div>
                            <div>
                                <strong className="block text-stone-900 mb-1">&nbsp;</strong>
                                <ul className="space-y-1">
                                    <li>Ind: Indicative</li>
                                    <li>Subj: Subjunctive</li>
                                    <li>Act/Pass: Active/Passive</li>
                                    <li>Inf: Infinitive</li>
                                </ul>
                            </div>
                        </div>

                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<LatinReader />);
    </script>
</body>
</html>
